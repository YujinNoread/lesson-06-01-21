const {} = require('../array_lib/array_lib')

describe('Array functions QA', () => {

    test('1. Берет массив объектов и возвращает массив значений определенного поля', () => {
        expect([{name: "tony", age: 20}, {name: "feel", age: 30},].pluck('name')).toEqual(['tony', 'feel']);
    });
    test('3. Разделяет массив на заданное количество подмассивов', () => {
        expect(["a", "b", "c", "d", "e", "f"].splitArray(2)).toEqual([['a', 'b'], ['c', 'd'], ['e', 'f']]);
    });
    test('4. Удаляем из массива все "отрицательные" типы данных ', () => {
        expect([1, 0, 2, false, "", 3].clearArray()).toEqual([1, 2, 3]);
    });
    test('5. Конкатенирует исходный массив с другими массивами или примитивными значениями', () => {
        expect([1].concatArray(2, [3], [[4]])).toEqual([1, 2, 3, [4]]);
    });
    test('6. Функция, которая удалит указанное кол-во элементов с начала исходного массива ', () => {
        expect([1, 2, 3].rm()).toEqual([2, 3]);
        expect([1, 2, 3].rm(2)).toEqual([3]);
        expect([1, 2, 3].rm(5)).toEqual([]);
        expect([1, 2, 3].rm(0)).toEqual([1, 2, 3]);
    });
    test('8. Функция, которая принимает массив, символ для замены, с какой ячейки начинать заменять и на какой остановиться.', () => {
        expect([1, 2, 3].replaceIn('a')).toEqual(['a', 'a', 'a']);
        expect([1, 2, 3].replaceIn(2)).toEqual([2, 2, 2]);
        expect([4, 6, 8, 10].replaceIn('*', 1, 3)).toEqual([4, '*', '*', 10]);
    });
    test('10. Функция, которая вернет массив со всеми значениями, которые повторяются в исходном массиве', () => {
        expect([1, 2, 3, 4, 2, 5, 6, 1, 3, 1, 3, 3, 1].uni()).toEqual([1, 2, 3]);
    });
    test('11. Функция, которая вернет элемент из массива по указанному индексу. Но если индекс отрицательный, то считаем с конца массива', () => {
        expect(['a', 'b', 'c', 'd'].nfa(1)).toEqual('a');
        expect(['a', 'b', 'c', 'd'].nfa(-2)).toEqual('c');
    });
    test('13. Функция, которая вернет массив с группированными элементами исходных массивов. ', () => {
        expect(['a', 'b'].group([1, 2], [true, false])).toEqual([['a', 1, true], ['b', 2, false]]);
    });
    test('14. Функция которая преобразует массив в строку через указанный разделитель ', () => {
        expect(['a', 'b', 'c'].implode('-')).toEqual('a-b-c');
    });
    test('17. Функция, которая перемешает массив в случайном порядке', () => {
        expect([1, 2, 3, 4, 5, 6].rnd()).not.toEqual([1, 2, 3, 4, 5, 6]);
    });
    test('18. Функция, которая вернет разницу двух массивов (т.е. элементы, которых нет в исходных массивах)', () => {
        expect([1, 2, 'a'].diff([1, 2, 3, 4, 'b'])).toEqual(['a', 3, 4, 'b']);
    });
    test('20. Функция, которая вернет самый частый элемент массива ', () => {
        expect([7, 'z', 'z', 'z', 3, 7, 'z', 7, 'z', 3, 5, 9, 7].fn()).toEqual(['z']);
    });
});
